<Biml xmlns="http://schemas.varigence.com/biml.xsd">
    <#@ template language="C#" hostspecific="true" tier="3"#>
    <#@ import namespace="System.Data" #>
    <#@ import namespace="Varigence.Languages.Biml.Connection" #>
    <#@ import namespace="Varigence.Biml.Extensions" #>
    <#@ import namespace="Varigence.Biml.CoreLowerer.SchemaManagement"#>
    <#@ include file="ProjectSettings.cs" #>
    
    <!-- http://www.varigence.com/Documentation/Language/Element/AstRootNode -->
    
    <!-- declare packages -->
    <Packages>
        <# // PrimaryKey constraint wordt per tabel opgehaald.
        string sqlSourceExtractionTable = @"with COLUMN_CONSTRAINTS(TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME)
                                            AS (
                                                select TC.TABLE_SCHEMA COLLATE SQL_Latin1_General_CP1_CS_AS, TC.TABLE_NAME COLLATE SQL_Latin1_General_CP1_CS_AS  , COLUMN_NAME COLLATE SQL_Latin1_General_CP1_CS_AS  
                                                from [Staging].[INFORMATION_SCHEMA].[TABLE_CONSTRAINTS] TC
                                                JOIN [Staging].[INFORMATION_SCHEMA].[CONSTRAINT_COLUMN_USAGE] CCL
                                                ON	TC.CONSTRAINT_CATALOG = CCL.CONSTRAINT_CATALOG
                                                AND	TC.CONSTRAINT_SCHEMA = CCL.CONSTRAINT_SCHEMA
                                                AND TC.CONSTRAINT_NAME = CCL.CONSTRAINT_NAME
                                            )
                                            ,CONSTRAINTS(TABLE_SCHEMA, TABLE_NAME, PK) AS (
                                                select distinct T1.TABLE_SCHEMA COLLATE SQL_Latin1_General_CP1_CS_AS  , T1.TABLE_NAME COLLATE SQL_Latin1_General_CP1_CS_AS ,
                                                STUFF((SELECT  ',' + T2.COLUMN_NAME
                                                from COLUMN_CONSTRAINTS T2
                                                where T1.TABLE_SCHEMA COLLATE SQL_Latin1_General_CP1_CS_AS = T2.TABLE_SCHEMA COLLATE SQL_Latin1_General_CP1_CS_AS AND T1.TABLE_NAME COLLATE SQL_Latin1_General_CP1_CS_AS = T2.TABLE_NAME COLLATE SQL_Latin1_General_CP1_CS_AS
                                                FOR XML PATH('')),1 ,1, '')    PK
                                                from COLUMN_CONSTRAINTS T1
                                            )
                                                SELECT   
                                                    ST.[SourceConnection]
                                                    ,ST.[SourceSchema]
                                                    ,ST.[SourceTable]
                                                    ,SC.[Type] AS [SourceType]
                                                    ,SC.[Options]
                                                    ,SC.[ConnectionString]
                                                    ,ST.[ExtractionType]
                                                    ,ST.[TargetConnection]
                                                    ,ST.[TargetSchema]
                                                    ,ST.[TargetTable]
                                                    ,ST.[IncrementalSchema]
                                                    ,ST.[IncrementalTable]
                                                    ,ST.[IncrementalUpdateColumn]
                                                    ,ST.[IncrementalKeyColumn]
                                                    ,ST.[IsStaging] 
                                                    ,CS.PK						AS [PrimaryKey]
                                                    ,CASE WHEN [IsStaging] = '1' THEN 'STG' ELSE 'EXTR' END AS PackagePrefix
                                                    ,ST.[WhereStatement]
                                                FROM      [Generator].[SourceExtractionTable] ST
                                                LEFT JOIN [Generator].[Connection]            SC
                                                ON        ST.[SourceConnection] = SC.[Name]
                                                LEFT JOIN CONSTRAINTS CS
                                            ON		    ST.[TargetSchema] = CS.[TABLE_SCHEMA]
                                                AND		ST.[TargetTable]  = CS.[TABLE_NAME]
                                                WHERE   ST.[IsActive] = 1
                                                AND		ST.SourceConnection = 'Staging'
                                            ";
        DataTable tableSourceExtractionTable = ExternalDataAccess.GetDataTable(conGeneratorConnectionString, sqlSourceExtractionTable);
        foreach (DataRow rowSourceExtractionTable in tableSourceExtractionTable.Rows)
        {
            string varExtractionSourceConnection = rowSourceExtractionTable["SourceConnection"].ToString();
            string varExtractionSourceSchema = rowSourceExtractionTable["SourceSchema"].ToString();
            string varExtractionSourceTable = rowSourceExtractionTable["SourceTable"].ToString();
            string varExtractionSourceType = rowSourceExtractionTable["SourceType"].ToString();
            string varExtractionOptions = rowSourceExtractionTable["Options"].ToString();
            string varExtractionConnectionString = rowSourceExtractionTable["ConnectionString"].ToString();
            string varExtractionType = rowSourceExtractionTable["ExtractionType"].ToString();
            string varExtractionTargetConnection = rowSourceExtractionTable["TargetConnection"].ToString();
            string varExtractionTargetSchema = rowSourceExtractionTable["TargetSchema"].ToString();
            string varExtractionTargetTable = rowSourceExtractionTable["TargetTable"].ToString();
            string varExtractionIncrementalSchema = rowSourceExtractionTable["IncrementalSchema"].ToString();
            string varExtractionIncrementalTable = rowSourceExtractionTable["IncrementalTable"].ToString();
            string varExtractionModifiedDate = rowSourceExtractionTable["IncrementalUpdateColumn"].ToString();
            string varExtractionIncrementalKey = rowSourceExtractionTable["IncrementalKeyColumn"].ToString();
            string varExtractionTargetTablePK = rowSourceExtractionTable["PrimaryKey"].ToString();
            string varExtractionWhereStatement = rowSourceExtractionTable["WhereStatement"].ToString();
            if (varExtractionWhereStatement.Length > 0) {
                varExtractionWhereStatement = "AND "+varExtractionWhereStatement;
            }
            
            //string ConnectionStringXSD =  @"@[$Project::DirImport]" + @"+"""+ varExtractionOptions.Replace("\\","\\\\") + @"""";
            //string ConnectionStringXSD2 = @"@[$Project::DirImport]" + @"+"""+ varExtractionConnectionString.Replace("\\","\\\\") + @"""";
            string ConnectionStringXSD = varExtractionOptions.Replace("\\","\\\\");
            string ConnectionStringXSD2 = @"@[$Project::DirImport]" + @"+"""+  varExtractionOptions.Replace("\\","\\\\")+ @"""";
            
            //The IsStaging flag indicates that the Staging database itself is the source of the extraction
            bool varIsStaging = (bool)rowSourceExtractionTable["IsStaging"];
            string varExtractionPackagePrefix = rowSourceExtractionTable["PackagePrefix"].ToString();
            
            string varTargetConnection = varExtractionTargetConnection;
            string varTargetSchema = varExtractionTargetSchema;
            string varTargetTable = varExtractionTargetTable;
            string varTargetName = varTargetConnection+"-"+varExtractionTargetSchema+"-"+varExtractionTargetTable;
            string varIncrementalName = varTargetConnection+"-"+varExtractionIncrementalSchema+"-"+varExtractionIncrementalTable;
            string varOutputPathName = "";
            string varTableBeginCharacter = varSQLServTableBeginCharacter;
            string varTableCloseCharacter = varSQLServTableCloseCharacter;
            string varColumnBeginCharacter = varSQLServColumnBeginCharacter;
            string varColumnCloseCharacter = varSQLServColumnCloseCharacter;
            
            if (varExtractionType == "IM" | varExtractionType == "MA")  { // I=Incremental, M=Modified
                string varIncrementalConnection = varExtractionTargetConnection;
                string varIncrementalSourceSchema = varExtractionIncrementalSchema;
                string varIncrementalSourceTable = varExtractionIncrementalTable;
                string varIncrementalTargetSchema = varExtractionTargetSchema;
                string varIncrementalTargetTable = varExtractionTargetTable;
                varTargetSchema = varExtractionIncrementalSchema;
                varTargetTable = varExtractionIncrementalTable;
            } 
            
            switch (varExtractionSourceType) {
                case "Oracle":
                    varTableBeginCharacter = varOracleObjectBeginEndCharacter;
                    varTableCloseCharacter = varOracleObjectBeginEndCharacter;
                    varColumnBeginCharacter = varOracleObjectBeginEndCharacter;
                    varColumnCloseCharacter = varOracleObjectBeginEndCharacter;
                    break;
                case "SQLServer":
                    varTableBeginCharacter = varSQLServTableBeginCharacter;
                    varTableCloseCharacter = varSQLServTableCloseCharacter;
                    varColumnBeginCharacter = varSQLServColumnBeginCharacter;
                    varColumnCloseCharacter = varSQLServColumnCloseCharacter;
                    break;
                default:
                    varTableBeginCharacter = varODBCObjectBeginEndCharacter;
                    varTableCloseCharacter = varODBCObjectBeginEndCharacter;
                    varColumnBeginCharacter = varODBCObjectBeginEndCharacter;
                    varColumnCloseCharacter = varODBCObjectBeginEndCharacter;
                    break;
            }
            
            //Add name qualifier to the table names
            string varExtractionTargetSchemaTablePlus = varSQLServTableBeginCharacter + varExtractionTargetSchema + varSQLServTableCloseCharacter + "." + varSQLServTableBeginCharacter + varExtractionTargetTable      + varSQLServTableCloseCharacter;
            string varExtractionIncrementalSchemaTablePlus = varSQLServTableBeginCharacter + varExtractionIncrementalSchema + varSQLServTableCloseCharacter + "." + varSQLServTableBeginCharacter + varExtractionIncrementalTable + varSQLServTableCloseCharacter;
            string varIncrementalSourceSchemaTablePlus = varSQLServTableBeginCharacter + varExtractionIncrementalSchema + varSQLServTableCloseCharacter + "." + varSQLServTableBeginCharacter + varExtractionIncrementalTable + varSQLServTableCloseCharacter;
            string varIncrementalTargetSchemaTablePlus = varSQLServTableBeginCharacter + varExtractionTargetSchema + varSQLServTableCloseCharacter + "." + varSQLServTableBeginCharacter + varExtractionTargetTable      + varSQLServTableCloseCharacter;
            string varTargetSchemaPlus = varSQLServTableBeginCharacter + varTargetSchema + varSQLServTableCloseCharacter;
            string varTargetTablePlus = varSQLServTableBeginCharacter + varTargetTable + varSQLServTableCloseCharacter;
            string varTargetSchemaTablePlus = varTargetSchemaPlus + "." + varTargetTablePlus;
            
            string varSQLRowCountTargetTable = "SELECT count(*) FROM " + varExtractionTargetSchemaTablePlus;
            string varSQLMaxIncrementalKeyTargetTable = "";
            if (varExtractionType == "MI") {
                varSQLMaxIncrementalKeyTargetTable = "SELECT MAX(" + varExtractionModifiedDate + ") FROM " + varExtractionTargetSchemaTablePlus;
            } else {
                varSQLMaxIncrementalKeyTargetTable = "SELECT '0'";
            }
            string varSQLTruncateTargetTable = "TRUNCATE TABLE " + varTargetSchemaTablePlus;
            string varSQLSelectSourceExtractionControl = "SELECT MAX(LastDate) AS LastDate, MAX(LastID) AS LastID from (SELECT CONVERT(VARCHAR, MAX([LastExtractionDate]), 120) AS LastDate, MAX(LastExtractionID) AS LastID \nFROM [Control].[SourceExtractionControl] \nWHERE [SourceConnection] = '"+varExtractionSourceConnection+"' \nAND [SourceSchema] = '"+varExtractionSourceSchema+"' \nAND [SourceTable] = '"+varExtractionSourceTable+"' UNION SELECT CONVERT(DATE,'20000101',120), CAST(0 AS BIGINT))a";
            string varSQLUpdateSourceExtractionControl = "MERGE [Control].[SourceExtractionControl] T   \n USING (Select '"+varExtractionSourceConnection+"' as [SourceConnection] \n , '"+varExtractionSourceSchema+"' as [SourceSchema] \n , '"+varExtractionSourceTable+"' as [SourceTable] \n , '"+varExtractionType+"' as [ExtractionType] \n , ? as [BatchID]  \n , ? as [RowCountExtract]  \n , ? as [RowCountTarget]  \n , ? as [RowCountError]  \n , ? as [LastExtractionDate] \n , ? as [LastExtractionID]  \n ) S  \n ON  T.[SourceConnection] = S.[SourceConnection] AND  T.[SourceSchema] = S.[SourceSchema]  AND T.[SourceTable] = S.[SourceTable]  \n WHEN NOT MATCHED BY TARGET THEN INSERT ([SourceConnection], [SourceSchema], [SourceTable], [ExtractionType], [BatchID], [RowCountExtract],[RowCountTarget],[RowCountError],[LastExtractionDate],[LastExtractionID]) VALUES ( S.[SourceConnection] \n , S.[SourceSchema] \n , S.[SourceTable] \n , S.[ExtractionType] \n , S.[BatchID] \n , S.[RowCountExtract] \n , S.[RowCountTarget] \n , S.[RowCountError] \n , S.[LastExtractionDate] \n , S.[LastExtractionID]   )   \n WHEN MATCHED  THEN \n UPDATE \n SET \n  [ExtractionType] = S.[ExtractionType] \n , [BatchID] = S.[BatchID] \n , [RowCountExtract] = S.[RowCountExtract] \n , [RowCountTarget] = S.[RowCountTarget] \n , [RowCountError] = S.[RowCountError] \n , [LastExtractionDate] = S.[LastExtractionDate] \n , [LastExtractionID] = S.[LastExtractionID] ;";
            string varExtractionSourceSchemaPlus = varTableBeginCharacter + varExtractionSourceSchema + varTableCloseCharacter +".";
            
            if (varExtractionSourceSchema == "") {
                varExtractionSourceSchemaPlus = "";
            }
            
            string varExtractionSourceTablePlus = varTableBeginCharacter + varExtractionSourceTable  + varTableCloseCharacter;
            string varName = varExtractionSourceConnection + "-" + varExtractionSourceSchema + "-" + varExtractionSourceTable;
            
            //Indien XML dan schema en tabelnaam weglaten
            switch (varExtractionSourceType) {
                case "XML_Enkel": 
                case "XML":
                case "XML_Kewill":
                case "XML_IFS":
                case "CSV":
                case "CSV_L":
                case "ODBC":
                    varName = varExtractionSourceSchema + "-" + varExtractionSourceConnection;
                    break;
            }
            
            string varPackageName    = varExtractionPackagePrefix + "-" + varName;
            
            //Create Source Extraction Query
            //The Metadata only contains Column mappings for tables that need some kind of data processing. For example a data conversion.
            //If such data transformation is needed, all columns must be specified.
            //It's also possible to specify expressions on the Source column. These expressions must be valid SQL for the source.
            //They are taken literally in the SELECT list.
            //For example: you may need to convert a column at the source, then you can use: CAST(MyColumn AS NUMERIC(18,4)) AS MyColumn
            //This would be something you may use to specifically convert the Oracle NUMBER (without precision) type.
            //You would also add Column qualifiers for columns that have special characters in them (e.g. "My Column")
            
            string sqlSourceExtractionColumn = @"SELECT 
                                                    ISNULL(sc.[SourceColumnName],ic.COLUMN_NAME) as[SourceColumnName]
                                                    ,ISNULL(sc.[SourceColumnExpression],ic.COLUMN_NAME)	as [SourceColumnExpression]
                                                    ,ISNULL(sc.[SourceColumnType], ic.DATA_TYPE) as [SourceColumnType]
                                                    ,ISNULL(ISNULL(sc.[SourceColumnLength], ic.CHARACTER_MAXIMUM_LENGTH),0)	as [SourceColumnLength]
                                                    ,ISNULL(ISNULL(sc.[SourceColumnPrecision], ic.NUMERIC_PRECISION),0) as [SourceColumnPrecision]
                                                    ,ISNULL(ISNULL(sc.[SourceColumnScale], ic.NUMERIC_SCALE),0) as [SourceColumnScale]
                                                    ,ISNULL(sc.[TargetColumnName],ic.COLUMN_NAME) as [TargetColumnName]
                                                    ,ISNULL(sc.[TargetColumnExpression],ic.COLUMN_NAME) as [TargetColumnExpression]
                                                    ,ISNULL(sc.[TargetColumnType], ic.DATA_TYPE) as [TargetColumnType]
                                                    ,ISNULL(ISNULL(sc.[TargetColumnLength], ic.CHARACTER_MAXIMUM_LENGTH),0)	as [TargetColumnLength]
                                                    ,ISNULL(ISNULL(sc.[TargetColumnPrecision], ic.NUMERIC_PRECISION),0) as [TargetColumnPrecision]
                                                    ,ISNULL(ISNULL(sc.[TargetColumnScale], ic.NUMERIC_SCALE),0) as [TargetColumnScale]
                                                    ,CASE WHEN sc.[SourceColumnType] <> [TargetColumnType] OR sc.[SourceColumnLength] <> [TargetColumnLength] OR sc.[SourceColumnPrecision] <> [TargetColumnPrecision] OR sc.[SourceColumnScale] <> [TargetColumnScale] THEN 1 ELSE 0 END AS [ColumnConversionNecessary]
                                                    ,dc.[DataTypeExpression]
                                                    FROM         [Staging].INFORMATION_SCHEMA.COLUMNS ic
                                                    INNER JOIN	  [Generator].[SourceExtractionTable] st
                                                    on			  st.TargetSchema = ic.TABLE_SCHEMA and st.TargetTable = ic.TABLE_NAME
                                                    AND          st.[IsActive] =  1
                                                    LEFT JOIN	  [Generator].[SourceExtractionColumn] sc
                                                    ON			  sc.TargetColumnName = ic.COLUMN_NAME and sc.SourceSchema = st.SourceSchema and sc.SourceTable = st.SourceTable
                                                    AND          sc.[IsActive] =  1
                                                    LEFT JOIN    [Generator].[DataTypeConversion]     dc
                                                    ON           ic.DATA_TYPE collate SQL_Latin1_General_CP1_CS_AS =  [DataType] collate SQL_Latin1_General_CP1_CS_AS
                                                    WHERE        st.[SourceConnection] = '" + varExtractionSourceConnection + @"'
                                                    AND          st.[SourceSchema] = '" + varExtractionSourceSchema + @"' 
                                                    AND         st.[SourceTable] = '" + varExtractionSourceTable + @"' 
                                                    AND		  ic.COLUMN_NAME not in ('BatchID','ProcessLogID')
                                                    ORDER BY     ic.ORDINAL_POSITION
                                                    ";
            DataTable tableSourceExtractionColumn = ExternalDataAccess.GetDataTable(conGeneratorConnectionString, sqlSourceExtractionColumn);
            int varSourceExtractionColumnCount = tableSourceExtractionColumn.Rows.Count;
            
            string varSQLStatementColumns = "";
            foreach (DataRow rowSourceExtractionColumn in tableSourceExtractionColumn.Rows) {
                string varSourceColumnName             =  rowSourceExtractionColumn["SourceColumnExpression"].ToString();
                if (varSourceColumnName == rowSourceExtractionColumn["SourceColumnName"].ToString() && varExtractionSourceType == "SQLServer") {
                    varSourceColumnName = "[" + varSourceColumnName + "]";
                }
                int varSourceColumnConversionNecessary = (int)rowSourceExtractionColumn["ColumnConversionNecessary"];
                varSQLStatementColumns += ", " + varSourceColumnName;
            }
            if (varSQLStatementColumns.Length > 0) { //remove first comma
                varSQLStatementColumns = varSQLStatementColumns.Substring(2, varSQLStatementColumns.Length - 2);
            } else {
                varSQLStatementColumns = "*";
            }
            string varExtractionSQLStatement = "";
            string varExtractionDateConversion = "";
            string varExtractionIDConversion = "0";
            varExtractionIDConversion = "&apos;&quot; + @[User::LastExtractionID] + &quot;&apos;";
            switch (varExtractionSourceType) {
                case "SQLServer":
                    varExtractionDateConversion = "CONVERT(DATETIME2(7), &apos;&quot; + @[User::LastExtractionDate] + &quot;&apos;, 120)";
                    break;
                case "Oracle":
                    varExtractionDateConversion = "TO_DATE(&apos;&quot; + @[User::LastExtractionDate] + &quot;&apos;, &apos;yyyy-mm-dd hh24:mi:ss&apos;)"; 
                    break;
                case "ODBC":
                    varExtractionDateConversion = "CAST(&apos;&quot; + @[User::LastExtractionDate] + &quot;&apos; AS TIMESTAMP)";
                    break;
                default:
                    varExtractionDateConversion = "CAST(&apos;&quot; + @[User::LastExtractionDate] + &quot;&apos; AS TIMESTAMP)";
                    break;
            }
            
            if (varExtractionType == "MN") {
                varExtractionSQLStatement = "\"SELECT " + varSQLStatementColumns + " FROM \\\"" + varExtractionSourceSchema + "\\\".\\\"" + varExtractionSourceTable+ "\\\" WHERE " + varExtractionModifiedDate + " >= " + varExtractionDateConversion + "\"";
                string varSQLLastRunDate = "(SELECT MAX(" + varExtractionModifiedDate + ") FROM [Staging]." + varTargetSchemaPlus +"."+ varTargetTablePlus +")";
            } else if (varExtractionType == "MI")  {
                varExtractionSQLStatement = "\"SELECT " + varSQLStatementColumns + " FROM \\\"" + varExtractionSourceSchema + "\\\".\\\"" + varExtractionSourceTable+ "\\\" WHERE " + varExtractionModifiedDate + " >= " + varExtractionIDConversion + "\"";
                string varSQLLastRunDate = "(SELECT MAX(" + varExtractionModifiedDate + ") FROM [Staging]." + varTargetSchemaPlus +"."+ varTargetTablePlus +")";
            } else  {
                if (varExtractionSourceType == "Excel2007") {
                    varExtractionSQLStatement = "SELECT " + varSQLStatementColumns + " FROM " + varExtractionSourceTable;
                } else if (varExtractionSourceType == "ODBC") {
                    varExtractionSQLStatement = "SELECT " + varSQLStatementColumns + " FROM " + varExtractionSourceTable + " WHERE 1=1 " + varExtractionWhereStatement;
                } else {
                    varExtractionSQLStatement = "SELECT " + varSQLStatementColumns + " FROM " + varExtractionSourceSchemaPlus + varExtractionSourceTablePlus + " WHERE 1=1 " + varExtractionWhereStatement;
                }
            }#>
    
            <Package Name="<#=varPackageName#>" ConstraintMode="Linear" ProtectionLevel="<#=ProjectProtectionLevel#>">
                <Parameters>
                    <Parameter Name="BatchID" DataType="Int64">-1</Parameter>
                    <Parameter Name="ProcessLogParentID" DataType="Int64">0</Parameter>
                </Parameters>
                <Variables>
                    <Variable Name="AuditActionStart" DataType="String" Namespace="Audit">S</Variable>
                    <Variable Name="AuditBatchActionNone" DataType="String" Namespace="Audit">N</Variable>
                    <Variable Name="AuditActionFinish" DataType="String" Namespace="Audit">F</Variable>
                    <Variable Name="AuditActionError" DataType="String" Namespace="Audit">E</Variable>
                    <Variable Name="AuditProcessLogID" DataType="Int64" Namespace="Audit">0</Variable>
                    <Variable Name="AuditBatchID" DataType="Int64" Namespace="Audit">0</Variable>
                    <Variable Name="PackageName" DataType="String" Namespace="User"><#=varPackageName#></Variable>
                    <Variable Name="RowCountExtract" DataType="Int32" Namespace="RC">0</Variable>
                    <Variable Name="RowCountTarget" DataType="Int32" Namespace="RC">0</Variable>
                    <Variable Name="RowCountError" DataType="Int32" Namespace="RC">0</Variable>
                    <Variable Name="MaxIncrementalKey" DataType="String" Namespace="RC">0</Variable>
                    <Variable Name="LastExtractionDate" DataType="String" Namespace="User">2000-01-01 00:00:00</Variable>
                    <Variable Name="LastExtractionID" DataType="String" Namespace="User">0</Variable>
                    <Variable Name="ExtractionType" DataType="String" Namespace="User"><#=varExtractionType#></Variable>
                    <Variable Name="sFullFilePath" DataType="String" Namespace="User">E:\DWHWork\Input\test.csv</Variable>
                    <Variable Name="sSourceFolder" DataType="String" Namespace="User"></Variable>
                    <#if (varExtractionType == "MN" | varExtractionType == "MI") {#>              
                        <Variable Name="SourceExtractionSQL" DataType="String" Namespace="User" EvaluateAsExpression="true"><#=varExtractionSQLStatement#></Variable> 
                    <#} else {#> 
                        <Variable Name="SourceExtractionSQL" DataType="String" Namespace="User"><#=varExtractionSQLStatement#></Variable> 
                    <#}#>
                </Variables>
                <Tasks>
                    <ExecuteSQL Name="SQL Start Audit Package <#=varName#>" ConnectionName ="<#=SystemConnection#>" ResultSet="SingleRow">
                        <DirectInput>EXECUTE [Logging].[PrcLoggingPackageExecution] @Action = ?,@BatchAction = ?,@BatchID = ?,@ProcessLogParentID = ?,@ProcessLogID = ?,@PackageName = ?,@SysPkgID = ?,@SysPkgName = ?,@SysPkgVersionGUID = ?	,@SysPkgVersionMajor = ?,@SysPkgVersionMinor = ?,@SysPkgExecutionMachineName = ?,@SysPkgExecutionUserName = ?,@SysPkgExecutionInstanceGUID = ?,@ExtractionType = ?</DirectInput>
                        <Parameters>
                            <Parameter Name="0" VariableName="Audit.AuditActionStart" Direction="Input" DataType="String"/>
                            <Parameter Name="1" VariableName="Audit.AuditBatchActionNone" Direction="Input" DataType="String"/>
                            <Parameter Name="2" VariableName="BatchID" Direction="Input"   DataType="Int64"/>
                            <Parameter Name="3" VariableName="ProcessLogParentID" Direction="Input" DataType="Int64"/>
                            <Parameter Name="4" VariableName="Audit.AuditProcessLogID" Direction="Input" DataType="Int64"/>
                            <Parameter Name="5" VariableName="User.PackageName" Direction="Input" DataType="String" />
                            <Parameter Name="6" VariableName="System.PackageID" Direction="Input" DataType="String" />
                            <Parameter Name="7" VariableName="System.PackageName" Direction="Input" DataType="String" />
                            <Parameter Name="8" VariableName="System.VersionGUID" Direction="Input" DataType="String" />
                            <Parameter Name="9" VariableName="System.VersionMajor" Direction="Input" DataType="Int32" />
                            <Parameter Name="10" VariableName="System.VersionMinor" Direction="Input" DataType="Int32" />
                            <Parameter Name="11" VariableName="System.MachineName" Direction="Input" DataType="String" />
                            <Parameter Name="12" VariableName="System.UserName" Direction="Input" DataType="String" />
                            <Parameter Name="13" VariableName="System.ExecutionInstanceGUID" Direction="Input" DataType="String" />
                            <Parameter Name="14" VariableName="User.ExtractionType" Direction="Input" DataType="String" />
                        </Parameters>
                        <Results>
                            <Result Name="0" VariableName="Audit.AuditBatchID" />
                            <Result Name="1" VariableName="Audit.AuditProcessLogID" />
                        </Results>
                    </ExecuteSQL>
    
                    <Container Name="SC Extract <#=varName#>" ConstraintMode="Linear">
                        <Tasks>
                            <ExecuteSQL Name="SQL Get last extraction date <#=varName#>" ConnectionName ="<#=SystemConnection#>" ResultSet="SingleRow" Disabled="false" >
                                <DirectInput><#=varSQLSelectSourceExtractionControl#></DirectInput>
                                <Results>
                                    <Result Name="LastDate" VariableName="User.LastExtractionDate" />
                                    <Result Name="LastID" VariableName="User.LastExtractionID" />
                                </Results>
                            </ExecuteSQL>
    
                            <ExecuteSQL Name="SQL Truncate table <#=varName#>" ConnectionName ="<#=varTargetConnection#>" ResultSet="None" Disabled="false" >
                                <DirectInput><#=varSQLTruncateTargetTable#></DirectInput>
                            </ExecuteSQL>
                            
                            <#string varTaskName = "Dataflow Extract " + varName;
                            string varSQLPackageTaskColumn = @"SELECT [ColumnName],[ColumnId] FROM [dbo].[PackageTaskColumn] WHERE [PackageName] = '" + varPackageName + @"' AND [TaskName] = '" + varTaskName + @"'";
    
                            if (varExtractionSourceType == "CSV_L" | varExtractionSourceType == "XML_Kewill" | varExtractionSourceType == "XML_IFS") {
                                string ConnectionStringCSV =  @"@[$Project::DirImport]" + @"+"""+ varExtractionConnectionString.Replace("\\","\\\\") + @"""";
                                string folder =  ConnectionStringCSV.Substring(0,ConnectionStringCSV.LastIndexOf("\\")+1) + @"""";
                                string file =  @""""+ConnectionStringCSV.Substring(ConnectionStringCSV.LastIndexOf("\\")+1 );
                                string filespec =  file.Replace(".","_*.");#>
                                <ForEachFileLoop Name="ForEach File Loop" Folder="folder" FileSpecification="filespec" ConstraintMode="Parallel" RetrieveFileNameFormat="FullyQualified">
                                <VariableMappings><VariableMapping Name="Mapping" VariableName="User.sFullFilePath"/></VariableMappings>
                                <Expressions>
                                    <Expression PropertyName="Directory"><#=folder#></Expression>
                                    <Expression PropertyName="FileSpec"><#=filespec#></Expression>
                                </Expressions>
                                <Tasks>
                            <#}#>
                            
                            <Dataflow Name="<#=varTaskName#>">
                                <#if (varExtractionSourceType == "XML_Kewill" ) {#>
                                    <Expressions><Expression ExternalProperty="[XML Source <#=varName#>].[XMLSchemaDefinition]"><#=ConnectionStringXSD2#></Expression></Expressions>
                                <#}#>
    
                                <Transformations>
                                    <#// Create Source
                                    switch (varExtractionSourceType) {
                                        case "FlatFile":#>
                                            <FlatFileSource Name="FF Source <#=varName#>" ConnectionName="<#=varExtractionSourceConnection#>">
                                                <ErrorHandling ErrorRowDisposition="RedirectRow" TruncationRowDisposition="RedirectRow" />
                                            </FlatFileSource>
                                            <#varOutputPathName = "FF Source " + varName;	
                                            break;
                                        case "CSV":
                                        case "CSV_L":#>
                                            <FlatFileSource Name="CSV Source <#=varName#>" ConnectionName="<#=varExtractionSourceConnection#>" RetainNulls="true">
                                                <ErrorHandling ErrorRowDisposition="RedirectRow" TruncationRowDisposition="RedirectRow" />
                                            </FlatFileSource>
                                            <#varOutputPathName = "CSV Source " + varName;	
                                            break;
                                        case "Excel2007":
                                        case "Excel97":#>
                                            <ExcelSource Name="Excel Source <#=varName#>" ConnectionName="<#=varExtractionSourceConnection#>" ValidateExternalMetadata="false">
                                                <ErrorHandling ErrorRowDisposition="RedirectRow" TruncationRowDisposition="RedirectRow" />
                                                <VariableInput VariableName="User.SourceExtractionSQL" />
                                            </ExcelSource>
                                            <#varOutputPathName = "Excel Source " + varName;	
                                            break;
                                        case "ODBC":#>
                                            <OdbcSource Name="ODBC Source <#=varName#>" Connection="<#=varExtractionSourceConnection#>" ValidateExternalMetadata="false">
                                                <ErrorHandling ErrorRowDisposition="RedirectRow" TruncationRowDisposition="RedirectRow" />
                                                <DirectInput><#=varExtractionSQLStatement#></DirectInput>
                                            </OdbcSource>
                                            <#varOutputPathName = "ODBC Source " + varName;	
                                            break;
                                        case "ODBCold":#>
                                            <AdoNetSource Name="ODBC Source <#=varName#>" ConnectionName="<#=varExtractionSourceConnection#>" ValidateExternalMetadata="false">
                                                <ErrorHandling ErrorRowDisposition="RedirectRow" TruncationRowDisposition="RedirectRow" />
                                                <DirectInput><#=varExtractionSQLStatement#></DirectInput>
                                            </AdoNetSource>
                                            <#varOutputPathName = "ODBC Source " + varName;	
                                            break;
                                        case "XML_Enkel":
                                        case "XML_Kewill":
                                        case "XML_IFS":
                                        case "XML":#>
                                            <XmlSource Name="XML Source <#=varName#>"> 
                                                <XmlSchemaFileInput ConnectionName="<#=varExtractionSourceConnection#>_XSD" /> 
                                                <FileNameFromVariableInput VariableName="User.sFullFilePath" /> 
                                                <ErrorHandling ErrorRowDisposition="RedirectRow" TruncationRowDisposition="RedirectRow" /> 
                                            </XmlSource>
                                            <#varOutputPathName = "XML Source " + varName;	
                                            break;
                                        default:#>
                                            <OleDbSource Name="OLEDB Source <#=varName#>" ConnectionName="<#=varExtractionSourceConnection#>" ValidateExternalMetadata="true">
                                                <ErrorHandling ErrorRowDisposition="RedirectRow" TruncationRowDisposition="RedirectRow" />
                                                <VariableInput VariableName="User.SourceExtractionSQL" />
                                            </OleDbSource>
                                            <#varOutputPathName = "OLEDB Source " + varName;	
                                            break;
                                        }#>
    
                                        <DerivedColumns Name="Derived Columns Error <#=varName#>"> 
                                            <#// Indien source is XML dan is outputpathname anders
                                            switch (varExtractionSourceType) {
                                                case "XML_Enkel":#>
                                                    <InputPath OutputPathName="<#=varOutputPathName#>.<#=varTargetTable#>Error" />
                                                    <#break;
                                                case "XML_Kewill":#>
                                                    <InputPath OutputPathName="<#=varOutputPathName#>.rowError" />
                                                    <#break;
                                                case "XML":
                                                case "XML_IFS":#>
                                                    <InputPath OutputPathName="<#=varOutputPathName#>.<#=varTargetTable#>Error" /> 
                                                    <#break;
                                                default:#>
                                                    <InputPath OutputPathName="<#=varOutputPathName#>.Error" />
                                                    <#break;
                                            }
                                            
                                            // Voeg primary key toe aan error message
                                            string varExtractionTargetTablePKLogging =" + (DT_WSTR,50)" + varExtractionTargetTablePK.Replace(",","+ \"; \" + (DT_WSTR,50)");
                                            if (varExtractionTargetTablePK.Length > 1 && varExtractionSourceType != "CSV" && varExtractionSourceType != "CSV_L" && varExtractionSourceType != "XML_Kewill") {
                                                varExtractionTargetTablePKLogging = varExtractionTargetTablePKLogging;
                                            } else {
                                                varExtractionTargetTablePKLogging = " + \"unknown\"";
                                            }#>
                                            <Columns>
                                                <Column Name="RecordType" DataType="String" Length="1"  ReplaceExisting="false">(DT_WSTR,1)"E"</Column>
                                                <Column Name="ErrorMessage" DataType="String" Length="200" ReplaceExisting="false">(DT_WSTR,6)"Code: " + (DT_WSTR,12)[ErrorCode] + (DT_WSTR,10)"; Column: " + (DT_WSTR,2)" (" + (DT_WSTR,4)[ErrorColumn] + (DT_WSTR,1)")" + " Key: "<#=varExtractionTargetTablePKLogging#></Column>
                                            </Columns>
                                        </DerivedColumns>
    
                                        <RowCount Name="RowCount Error <#=varName#>" VariableName="RC.RowCountError">
                                            <InputPath OutputPathName="Derived Columns Error <#=varName#>.Output" />
                                        </RowCount>
                                        <# switch (varExtractionSourceType) {
                                            case "XML_Enkel":
                                            case "XML_IFS":#>
                                                <DerivedColumns Name="Derived Columns FlatFile Error <#=varName#>">
                                                    <InputPath OutputPathName="RowCount Error <#=varName#>.Output" />
                                                    <Columns>
                                                        <Column Name="PackageName" DataType="String" Length="100"  ReplaceExisting="false">(DT_WSTR,100)@[System::PackageName]</Column>
                                                        <Column Name="FlatFile" DataType="String" Length="300"  ReplaceExisting="false">(DT_WSTR,300)@[User::PackageName]</Column>
                                                    </Columns>
                                                </DerivedColumns>
                                                
                                                <OleDbDestination Name="OLEDB Error <#=varName#>" ConnectionName="<#=SystemConnection#>" ValidateExternalMetadata="false" TableLock="false">
                                                    <InputPath OutputPathName="Derived Columns FlatFile Error <#=varName#>.Output" />
                                                    <ExternalTableOutput Table="[Logging].[XMLFileErrors]" />
                                                </OleDbDestination>
                                                <#varOutputPathName = varOutputPathName + "." + varTargetTable;
                                                break;
                                            case "XML_Kewill":#>
                                                <DerivedColumns Name="Derived Columns FlatFile Error <#=varName#>">
                                                    <InputPath OutputPathName="RowCount Error <#=varName#>.Output" />
                                                    <Columns>
                                                        <Column Name="PackageName" DataType="String" Length="100"  ReplaceExisting="false">(DT_WSTR,100)@[System::PackageName]</Column>
                                                        <Column Name="FlatFile" DataType="String" Length="300"  ReplaceExisting="false">(DT_WSTR,300)@[User::PackageName]</Column>
                                                    </Columns>
                                                </DerivedColumns>
                                                
                                                <OleDbDestination Name="OLEDB Error <#=varName#>" ConnectionName="<#=SystemConnection#>" ValidateExternalMetadata="false" TableLock="false">
                                                    <InputPath OutputPathName="Derived Columns FlatFile Error <#=varName#>.Output" />
                                                    <ExternalTableOutput Table="[Logging].[XMLFileErrors]" />
                                                </OleDbDestination>
                                                <#varOutputPathName = varOutputPathName + ".row" ;
                                                break;
                                            case "XML":#>
                                                <DerivedColumns Name="Derived Columns FlatFile Error <#=varName#>">
                                                    <InputPath OutputPathName="RowCount Error <#=varName#>.Output" />
                                                    <Columns>
                                                        <Column Name="PackageName" DataType="String" Length="100"  ReplaceExisting="false">(DT_WSTR,100)@[System::PackageName]</Column>
                                                        <Column Name="FlatFile" DataType="String" Length="300"  ReplaceExisting="false">(DT_WSTR,300)@[User::PackageName]</Column>
                                                    </Columns>
                                                </DerivedColumns>
                                                
                                                <OleDbDestination Name="OLEDB Error <#=varName#>" ConnectionName="<#=SystemConnection#>" ValidateExternalMetadata="false" TableLock="false">
                                                    <InputPath OutputPathName="Derived Columns FlatFile Error <#=varName#>.Output" />
                                                    <ExternalTableOutput Table="[Logging].[XMLFileErrors]" />
                                                </OleDbDestination>
                                                
                                                <DerivedColumns Name="Derived Columns Header <#=varName#>">
                                                    <InputPath OutputPathName="<#=varOutputPathName#>.Header" />
                                                    <Columns>
                                                        <Column Name="PackageName" DataType="String" Length="100"  ReplaceExisting="false">(DT_WSTR,100)@[System::PackageName]</Column>
                                                        <Column Name="FlatFile" DataType="String" Length="300"  ReplaceExisting="false">(DT_WSTR,300)@[User::PackageName]</Column>
                                                        <Column Name="BatchID" DataType="Int64" Length="8" ReplaceExisting="false">@[Audit::AuditBatchID]</Column>
                                                        <Column Name="ProcessLogID" DataType="Int64" Length="8" ReplaceExisting="false">@[Audit::AuditProcessLogID]</Column>
                                                    </Columns>
                                                </DerivedColumns>
                                                
                                                <OleDbDestination Name="OLEDB Header <#=varName#>" ConnectionName="<#=SystemConnection#>" ValidateExternalMetadata="false" TableLock="false">
                                                    <InputPath OutputPathName="Derived Columns Header <#=varName#>.Output" />
                                                    <ExternalTableOutput Table="[Logging].[XMLLoadLog]" />
                                                </OleDbDestination>
                                                <#varOutputPathName = varOutputPathName + "." + varTargetTable;
                                                break;
                                            default:#>
                                                <UnionAll Name="Union <#=varName#>">
                                                    <InputPaths>
                                                        <InputPath OutputPathName="<#=varOutputPathName#>.Output" />
                                                        <InputPath OutputPathName="RowCount Error <#=varName#>.Output" /> 
                                                    </InputPaths>
                                                </UnionAll>
                                                <#varOutputPathName = "Union " + varName + ".Output";	
                                                break;
                                        }#>
                                        
                                        <DerivedColumns Name="Derived Column <#=varName#>">
                                            <InputPath OutputPathName="<#=varOutputPathName#>" />
                                            <Columns>
                                                <#foreach (DataRow rowSourceExtractionColumn in tableSourceExtractionColumn.Rows) {
                                                    string varSourceColumnName = rowSourceExtractionColumn["SourceColumnName"].ToString();
                                                    string varTargetColumnExpression = rowSourceExtractionColumn["TargetColumnExpression"].ToString();
                                                    string varSourceColumnType = rowSourceExtractionColumn["SourceColumnType"].ToString();
                                                    string varTargetDataTypeExpression = rowSourceExtractionColumn["DataTypeExpression"].ToString();
                                                    
                                                    if (varTargetColumnExpression == varSourceColumnName && varExtractionSourceType == "SQLServer")  {
                                                        varTargetColumnExpression = "[" + varTargetColumnExpression + "]";
                                                    }
                                                    
                                                    if (AllCharacterDataTypes.ToLower().IndexOf("-"+varSourceColumnType.ToLower()+"-") != -1) {#>
                                                        <Column Name="<#=varSourceColumnName#>" DataType="<#=varTargetDataTypeExpression#>" ReplaceExisting="true">TRIM(<#=varTargetColumnExpression#>)</Column>
                                                        <#} else if (varSourceColumnName != rowSourceExtractionColumn["TargetColumnExpression"].ToString()) {#>
                                                        <Column Name="<#=varSourceColumnName#>" DataType="<#=varTargetDataTypeExpression#>" ReplaceExisting="true"><#=varTargetColumnExpression#></Column>
                                                    <#}
                                                } #>
                                                <Column Name="BatchID" DataType="Int64" Length="8" ReplaceExisting="false">@[Audit::AuditBatchID]</Column>
                                                <Column Name="ProcessLogID" DataType="Int64" Length="8" ReplaceExisting="false">@[Audit::AuditProcessLogID]</Column>
                                            </Columns>
                                        </DerivedColumns>
    
                                        <#DataRow[] DataConversionRows;
                                        string FilterExpression = "ColumnConversionNecessary = 1";
                                        DataConversionRows = tableSourceExtractionColumn.Select(FilterExpression);
                                        
                                        if (DataConversionRows.Count() > 0) {                         #>
                                            <DataConversion Name="Data Conversion <#=varName#>">
                                            <InputPath OutputPathName="Derived Column <#=varName#>.Output" />
                                                <Columns>
                                                    <#foreach (DataRow rowSourceExtractionColumn in tableSourceExtractionColumn.Rows)  {
                                                        string varSourceColumnName = rowSourceExtractionColumn["SourceColumnName"].ToString();
                                                        string varTargetColumnName = rowSourceExtractionColumn["TargetColumnName"].ToString();
                                                        string varTargetColumnType = rowSourceExtractionColumn["TargetColumnType"].ToString();
                                                        string varTargetDataTypeExpression = rowSourceExtractionColumn["DataTypeExpression"].ToString();
                                                        int varTargetColumnLength = (int)rowSourceExtractionColumn["TargetColumnLength"];
                                                        int varTargetColumnPrecision = (int)rowSourceExtractionColumn["TargetColumnPrecision"];
                                                        int varTargetColumnScale = (int)rowSourceExtractionColumn["TargetColumnScale"];
                                                        int varSourceColumnConversionNecessary = (int)rowSourceExtractionColumn["ColumnConversionNecessary"];
                                                        
                                                        if (varSourceColumnConversionNecessary == 1) {#>
                                                            <Column SourceColumn="<#=varSourceColumnName#>" TargetColumn="dc.<#=varSourceColumnName#>" DataType="<#=varTargetDataTypeExpression#>" Length="<#=varTargetColumnLength#>" Precision="<#=varTargetColumnPrecision#>" Scale="<#=varTargetColumnScale#>" />
                                                        <#}
                                                    }#>
                                                </Columns>
                                            </DataConversion>
                                            <#varOutputPathName = "Data Conversion " + varName;
                                            } else {
                                                varOutputPathName = "Derived Column " + varName;
                                            }#>
    
                                            <RowCount Name="RowCount Extraction <#=varName#>" VariableName="RC.RowCountExtract">
                                                <InputPath OutputPathName="<#=varOutputPathName#>.Output" />
                                            </RowCount>
                                    
                                            <OleDbDestination Name="OLEDB Target <#=varName#>" ConnectionName="<#=varTargetConnection#>" ValidateExternalMetadata="false" TableLock="false">
                                                <InputPath OutputPathName = "RowCount Extraction <#=varName#>.Output" />
                                                <ExternalTableOutput Table = "<#=varTargetSchemaTablePlus#>" />
                                                <#var StgConnection = RootNode.DbConnections[StagingConnection];
                                                var StgMetadata = StgConnection.ImportDB(varTargetSchema, varTargetTable, ImportOptions.ExcludeForeignKey | ImportOptions.ExcludeColumnDefault | ImportOptions.ExcludeViews);
                                                //There is only one item in this collection.
                                                foreach (var TabTargetTable in StgMetadata.TableNodes.Where(item => item.Name == varTargetTable)) {#>
                                                    <Columns>
                                                    <#foreach (var column in TabTargetTable.Columns) {
                                                        string varSourceColumnName = "";
                                                        string varTargetColumnName = "";
                                                        int varSourceColumnConversionNecessary  = 0;
                                                        // Check if there is an entry for this column in the SourceExtractonColumn table. This overrides the default 1-on-1 mapping
                                                        FilterExpression = "TargetColumnName = '" + column.Name + "'";
                                                        DataRow[] SourceExtractionRows;
                                                        // This should return only a single row
                                                        SourceExtractionRows = tableSourceExtractionColumn.Select(FilterExpression);
                                                        if (SourceExtractionRows.Count() > 0) {
                                                            DataRow rowSourceExtractionColumn  = SourceExtractionRows[0];
                                                            varSourceColumnName = rowSourceExtractionColumn["SourceColumnName"].ToString();
                                                            varTargetColumnName = rowSourceExtractionColumn["TargetColumnName"].ToString();
                                                            varSourceColumnConversionNecessary = (int)rowSourceExtractionColumn["ColumnConversionNecessary"];
                                                        } else {
                                                            varSourceColumnName = column.Name;
                                                            varTargetColumnName = column.Name;
                                                        }
                                                        if (varSourceColumnConversionNecessary == 1)  { #>
                                                            <Column SourceColumn="dc.<#=varSourceColumnName#>" TargetColumn="<#=varTargetColumnName#>" />
                                                            <#} else {#>
                                                            <Column SourceColumn="<#=varSourceColumnName#>" TargetColumn="<#=varTargetColumnName#>" />
                                                        <#}        
                                                    }#>
                                                    </Columns>
                                                <#}#>
                                            </OleDbDestination>
                                        </Transformations>
                                    </Dataflow>
                                    <#if (varExtractionSourceType == "CSV_L" | varExtractionSourceType == "XML_Kewill" | varExtractionSourceType == "XML_IFS") {#>
                                </Tasks>
                            </ForEachFileLoop>
                            <#}               
                            if (varExtractionType == "IAAA" | varExtractionType == "MAAA") {
                                string varSQLDeleteStatement = "";
                                string[] varKeyColumns = varExtractionIncrementalKey.Split(varKeyColumnSeparator,StringSplitOptions.RemoveEmptyEntries);
                                string varJoinCondition = "";
                                foreach (string varKeyColumn in varKeyColumns) {
                                    varJoinCondition += "AND tar.[" + varKeyColumn + "] = inc.[" + varKeyColumn + "] \n";
                                }
                                if (varJoinCondition.Length > 0) {
                                    varJoinCondition      = varJoinCondition.Substring(4, varJoinCondition.Length - 5);
                                }
                                varSQLDeleteStatement = varSQLDeleteStatement + "DELETE FROM "+varIncrementalTargetSchemaTablePlus+ " \n";
                                varSQLDeleteStatement = varSQLDeleteStatement + "FROM "+varIncrementalTargetSchemaTablePlus+" tar \n";
                                varSQLDeleteStatement = varSQLDeleteStatement + "INNER JOIN "+varIncrementalSourceSchemaTablePlus+" inc \n";
                                varSQLDeleteStatement = varSQLDeleteStatement + "ON "+varJoinCondition;#>
                
                                <ExecuteSQL Name="SQL Delete target <#=varName#>" ConnectionName ="<#=varTargetConnection#>" ResultSet="None" Disabled="false" >
                                    <DirectInput><#=varSQLDeleteStatement#></DirectInput>
                                </ExecuteSQL>
                                
                                <Dataflow Name="Dataflow Load <#=varName#>">
                                    <Transformations>
                                        <OleDbSource Name="OLEDB Source <#=varName#>" ConnectionName="<#=varTargetConnection#>">
                                            <ErrorHandling ErrorRowDisposition="IgnoreFailure" TruncationRowDisposition="IgnoreFailure" />
                                            <ExternalTableInput Table="<#=varIncrementalSourceSchemaTablePlus#>" />
                                        </OleDbSource>
                                        
                                        <OleDbDestination Name="OLEDB Target <#=varName#>" ConnectionName="<#=varTargetConnection#>" ValidateExternalMetadata="false" TableLock="false">
                                            <InputPath OutputPathName="OLEDB Source <#=varName#>.Output" />
                                            <ExternalTableOutput Table="<#=varIncrementalTargetSchemaTablePlus#>" />
                                        </OleDbDestination>
                                    </Transformations>
                                </Dataflow>
                            <#}#>
                
                            <ExecuteSQL Name="SQL Target row count <#=varName#>" ConnectionName ="<#=varTargetConnection#>" ResultSet="SingleRow" Disabled="false" >
                                <DirectInput><#=varSQLRowCountTargetTable#></DirectInput>
                                <Results><Result Name="0" VariableName="RC.RowCountTarget" /></Results>
                            </ExecuteSQL>
                
                            <ExecuteSQL Name="SQL Target Max Incremental key <#=varName#>" ConnectionName ="<#=varTargetConnection#>" ResultSet="SingleRow" Disabled="false" >
                                <DirectInput><#=varSQLMaxIncrementalKeyTargetTable#></DirectInput>
                                <Results><Result Name="0" VariableName="RC.MaxIncrementalKey" /></Results>
                            </ExecuteSQL>
                            
                            <ExecuteSQL Name="SQL Update contol record <#=varName#>" ConnectionName ="<#=SystemConnection#>" ResultSet="None" Disabled="false" >
                                <DirectInput><#=varSQLUpdateSourceExtractionControl#></DirectInput>
                                <Parameters>
                                    <Parameter Name="0" VariableName="BatchID" DataType="Int64" />
                                    <Parameter Name="1" VariableName="RC.RowCountExtract" DataType="Int32" />
                                    <Parameter Name="2" VariableName="RC.RowCountTarget" DataType="Int32" />
                                    <Parameter Name="3" VariableName="RC.RowCountError" DataType="Int32" />
                                    <Parameter Name="4" VariableName="System.StartTime" DataType="DateTime" />
                                    <Parameter Name="5" VariableName="RC.MaxIncrementalKey" DataType="String" />
                                </Parameters>
                            </ExecuteSQL>
                        </Tasks>
                    </Container>
    
                    <ExecuteSQL Name="SQL Finish Audit Package <#=varName#>" ConnectionName ="<#=SystemConnection#>" ResultSet="None">
                        <DirectInput>EXECUTE [Logging].[PrcLoggingPackageExecution] @Action = ?,@BatchAction = ?,@BatchID = ?,@ProcessLogID = ?,@LastExtractionDate = ?,@RowCountExtract = ?,@RowCountTarget = ?,@RowCountError = ?,@LastExtractionID = ?</DirectInput>
                        <Parameters>
                        <Parameter Name="0" VariableName="Audit.AuditActionFinish" Direction="Input" DataType="String"/>
                        <Parameter Name="1" VariableName="Audit.AuditBatchActionNone" Direction="Input" DataType="String"/>
                        <Parameter Name="2" VariableName="Audit.AuditBatchID" Direction="Input" DataType="Int64"/>
                        <Parameter Name="3" VariableName="Audit.AuditProcessLogID" Direction="Input" DataType="Int64"/>
                        <Parameter Name="4" VariableName="User.LastExtractionDate" Direction="Input" DataType="String" />
                        <Parameter Name="5" VariableName="RC.RowCountExtract" Direction="Input" DataType="Int32" />
                        <Parameter Name="6" VariableName="RC.RowCountTarget" Direction="Input" DataType="Int32" />
                        <Parameter Name="7" VariableName="RC.RowCountError" Direction="Input" DataType="Int32" />
                        <Parameter Name="8" VariableName="User.LastExtractionID" Direction="Input" DataType="String" />
                        </Parameters>
                    </ExecuteSQL>
                </Tasks>
                <#if (varExtractionSourceType == "XML_Kewill") {#>
                    <Connections>
                        <Connection ConnectionName="<#=varExtractionSourceConnection#>_XSD">
                            <Expressions><Expression PropertyName="<#=varExtractionSourceConnection#>_XSD.ConnectionString"><#=ConnectionStringXSD2#></Expression></Expressions>
                        </Connection>
                    </Connections>
                <#}#>
    
                <Events>
                    <Event Name="Package Error" ConstraintMode="Linear" EventType="OnError">
                        <Tasks>
                            <ExecuteSQL Name="SQL Error Audit Package <#=varName#>" ConnectionName ="<#=SystemConnection#>" ResultSet="None">
                                <DirectInput>exec [Logging].[PrcLogMessage]@ProcessLogID = ?,@BatchID = ?,@SourceName = ?,@EventCode = ?,@EventDescription = ?</DirectInput>
                                <Parameters>
                                    <Parameter Name="0" VariableName="Audit.AuditProcessLogID" Direction="Input" DataType="Int64"/>
                                    <Parameter Name="1" VariableName="Audit.AuditBatchID" Direction="Input" DataType="Int64"/>
                                    <Parameter Name="2" VariableName="User.PackageName" Direction="Input" DataType="String"/>
                                    <Parameter Name="3" VariableName="System.ErrorCode" Direction="Input" DataType="Int32"/>
                                    <Parameter Name="4" VariableName="System.ErrorDescription" Direction="Input" DataType="String" />
                                </Parameters>
                            </ExecuteSQL>
                        </Tasks>
                    </Event>
                </Events>
            </Package>
        <#}#>

        <!-- create overall package. One per Target schema.-->
        <# string sqlTargetSchemas = @"SELECT DISTINCT
                                        [TargetConnection]
                                        ,[TargetSchema]
                                        ,'Total' AS [TargetTable]
                                        ,CASE WHEN [IsStaging] = '1' THEN 'CTRL-STG' ELSE 'CTRL-EXTR' END AS PackagePrefix
                                        ,[IsStaging]
                                        FROM [Generator].[SourceExtractionTable] st
                                        WHERE st.[IsActive] =  1
                                        AND st.SourceConnection = 'Staging'
                                        ";
        
        DataTable tableTargetSchemas = ExternalDataAccess.GetDataTable(conGeneratorConnectionString, sqlTargetSchemas);
        foreach (DataRow rowTargetSchemas in tableTargetSchemas.Rows) {
            string varTargetConnection = rowTargetSchemas["TargetConnection"].ToString();
            string varTargetSchema = rowTargetSchemas["TargetSchema"].ToString();
            string varTargetTable = rowTargetSchemas["TargetTable"].ToString();
            string varPackagePrefix = rowTargetSchemas["PackagePrefix"].ToString();
            string varTargetIsStaging = rowTargetSchemas["IsStaging"].ToString();
            string varName = varTargetConnection + "-" + varTargetSchema + "-" + varTargetTable;
            string varPackageName = varPackagePrefix + "-" + varTargetConnection + "-" + varTargetSchema + "-" + varTargetTable;#>

            <Package Name="<#=varPackageName#>" ConstraintMode="Linear" AutoCreateConfigurationsType="None" ProtectionLevel="<#=ProjectProtectionLevel#>" MaxConcurrentExecutables="4" MaxErrorCount="0">
                <Parameters>
                    <Parameter Name="BatchID" DataType="Int64">-1</Parameter>
                    <Parameter Name="ProcessLogParentID" DataType="Int64">0</Parameter>
                </Parameters>

                <Variables>
                    <Variable Name="AuditActionStart" DataType="String" Namespace="Audit">S</Variable>
                    <Variable Name="AuditBatchActionStart" DataType="String" Namespace="Audit">S</Variable>
                    <Variable Name="AuditBatchActionNone" DataType="String" Namespace="Audit">N</Variable>
                    <Variable Name="AuditBatchActionError" DataType="String" Namespace="Audit">E</Variable>
                    <Variable Name="AuditBatchActionFinish" DataType="String" Namespace="Audit">F</Variable>
                    <Variable Name="AuditActionFinish" DataType="String" Namespace="Audit">F</Variable>
                    <Variable Name="AuditActionError" DataType="String" Namespace="Audit">E</Variable>
                    <Variable Name="AuditProcessLogID" DataType="Int64" Namespace="Audit">0</Variable>
                    <Variable Name="AuditBatchID" DataType="Int64" Namespace="Audit" >-1</Variable>
                    <Variable Name="PackageName" DataType="String" Namespace="User"><#=varPackageName#></Variable>
                </Variables>
                
                <Tasks>
                    <ExecuteSQL Name="SQL Start Audit Package <#=varName#>" ConnectionName ="<#=SystemConnection#>" ResultSet="SingleRow">
                        <DirectInput>EXECUTE [Logging].[PrcLoggingPackageExecution] @Action = ?,@BatchAction = ?,@BatchID = ?,@ProcessLogParentID = ?,@ProcessLogID = ?,@PackageName = ?,@SysPkgID = ?,@SysPkgName = ?,@SysPkgVersionGUID = ?	,@SysPkgVersionMajor = ?,@SysPkgVersionMinor = ?,@SysPkgExecutionMachineName = ?,@SysPkgExecutionUserName = ?,@SysPkgExecutionInstanceGUID = ?</DirectInput>
                        <Parameters>
                            <Parameter Name="0" VariableName="Audit.AuditActionStart" Direction="Input" DataType="String"/>
                            <Parameter Name="1" VariableName="Audit.AuditBatchActionNone" Direction="Input" DataType="String"/>
                            <Parameter Name="2" VariableName="BatchID" Direction="Input" DataType="Int64"/>
                            <Parameter Name="3" VariableName="ProcessLogParentID" Direction="Input" DataType="Int64"/>
                            <Parameter Name="4" VariableName="Audit.AuditProcessLogID" Direction="Input" DataType="Int64"/>
                            <Parameter Name="5" VariableName="User.PackageName" Direction="Input" DataType="String" />
                            <Parameter Name="6" VariableName="System.PackageID" Direction="Input" DataType="String" />
                            <Parameter Name="7" VariableName="System.PackageName" Direction="Input" DataType="String" />
                            <Parameter Name="8" VariableName="System.VersionGUID" Direction="Input" DataType="String" />
                            <Parameter Name="9" VariableName="System.VersionMajor" Direction="Input" DataType="Int32" />
                            <Parameter Name="10" VariableName="System.VersionMinor" Direction="Input" DataType="Int32" />
                            <Parameter Name="11" VariableName="System.MachineName" Direction="Input" DataType="String" />
                            <Parameter Name="12" VariableName="System.UserName" Direction="Input" DataType="String" />
                            <Parameter Name="13" VariableName="System.ExecutionInstanceGUID" Direction="Input" DataType="String" />
                        </Parameters>
                       
                        <Results>
                            <Result Name="0" VariableName="Audit.AuditBatchID" />
                            <Result Name="1" VariableName="Audit.AuditProcessLogID" />
                        </Results>
                    </ExecuteSQL>

                    <Container Name="SC Extract <#=varName#>" ConstraintMode="Parallel" MaxErrorCount="0">
                        <Tasks>
                            <#string sqlSourcePackages = @"SELECT [SourceConnection]
                                                            ,[Type] AS ConnectionType
                                                            ,[SourceSchema] AS [SourceSchema]
                                                            ,[TargetTable] AS [SourceTable]
                                                            ,CASE WHEN [IsStaging] = '1' THEN 'STG' ELSE 'EXTR' END AS PackagePrefix
                                                            FROM      [Generator].[SourceExtractionTable] st 
                                                            JOIN	  [Generator].[Connection] con 	
                                                            ON		  [st].[SourceConnection] = [con].[Name]
                                                            WHERE     [TargetConnection] = '"  + varTargetConnection + @"' 
                                                            AND       [TargetSchema] = '" + varTargetSchema + @"' 
                                                            AND       [st].[IsActive] = 1 
                                                            AND       [IsStaging] = '" + varTargetIsStaging + @"' 
                                                            ORDER BY  [SourceTable]
                                                            ";
                            DataTable tableSourcePackages = ExternalDataAccess.GetDataTable(conGeneratorConnectionString, sqlSourcePackages);
                            foreach (DataRow rowSourcePackages in tableSourcePackages.Rows) { 
                                string varSourceConnection = rowSourcePackages["SourceConnection"].ToString();
                                string varConnectionType = rowSourcePackages["ConnectionType"].ToString();
                                string varSourceSchema = rowSourcePackages["SourceSchema"].ToString();
                                string varSourceTable = rowSourcePackages["SourceTable"].ToString();
                                string varPackagePrfx = rowSourcePackages["PackagePrefix"].ToString();
                                string varPackage = varPackagePrfx + "-" + varSourceConnection + "-" + varSourceSchema + "-" + varSourceTable + ".dtsx";
                                string varPackage2 = varPackagePrfx + "-" + varSourceConnection + "-" + varSourceSchema + "-" + varSourceTable + "_p2.dtsx";
                                string varPackage3 = varPackagePrfx + "-" + varSourceConnection + "-" + varSourceSchema + "-" + varSourceTable + "_p3.dtsx";
                                string varPackage4 = varPackagePrfx + "-" + varSourceConnection + "-" + varSourceSchema + "-" + varSourceTable + "_p4.dtsx";
                                string varScriptName = varSourceTable + "_script_1";
                                string varScriptCoreName = "ST_232feca_" + varSourceTable + "_script_1";
                                string varScriptTaskName = "Task_" + varSourceTable + "_script_1";
                                string varScriptName2 = varSourceTable + "_script_2";
                                string varScriptCoreName2 = "ST_232feca_" + varSourceTable + "_script_2";
                                string varScriptTaskName2 = "Task_" + varSourceTable + "_script_2";
                                string varScriptName3 = varSourceTable + "_script_3";
                                string varScriptCoreName3 = "ST_232feca_" + varSourceTable + "_script_3";
                                string varScriptTaskName3 = "Task_" + varSourceTable + "_script_3";
                                string varPackageXML = varPackagePrfx + "-" + varSourceSchema + "-" + varSourceConnection + ".dtsx";
                            
                                switch (varConnectionType) {
                                    case "XML_Enkel": 
                                    case "XML":
                                    case "XML_Kewill":
                                    case "XML_IFS":
                                    case "CSV":
                                    case "CSV_L":
                                    case "ODBC":
                                        varPackage = varPackageXML;
                                        break;
                                }#>
                                <ExecutePackage Name="<#=varPackage#>">
                                    <ExternalProjectPackage Package="<#=varPackage#>"/>
                                    <ParameterBindings>
                                        <ParameterBinding VariableName="Audit.AuditBatchID" Name="BatchID" />
                                        <ParameterBinding VariableName="Audit.AuditProcessLogID" Name="ProcessLogParentID" />
                                    </ParameterBindings>
                                </ExecutePackage>
                                
                                <Script ProjectCoreName="<#=varScriptCoreName#>" Name="<#=varScriptName#>">
                                    <PrecedenceConstraints>
                                        <Inputs>
                                            <Input OutputPathName="<#=varPackage#>.Output" EvaluationValue="Failure"/>
                                        </Inputs>
                                    </PrecedenceConstraints>
                                    <ScriptTaskProject>
                                        <ScriptTaskProject ProjectCoreName="<#=varScriptCoreName#>" Name="<#=varScriptTaskName#>">
                                            <AssemblyReferences>
                                                <AssemblyReference AssemblyPath="Microsoft.SqlServer.ManagedDTS.dll" />
                                                <AssemblyReference AssemblyPath="Microsoft.SqlServer.ScriptTask.dll" />
                                                <AssemblyReference AssemblyPath="System.dll" />
                                                <AssemblyReference AssemblyPath="System.AddIn.dll" />
                                                <AssemblyReference AssemblyPath="System.Data.dll" />
                                                <AssemblyReference AssemblyPath="System.Windows.Forms.dll" />
                                                <AssemblyReference AssemblyPath="System.Xml.dll" />
                                            </AssemblyReferences>
                                            <Files>
                                                <File Path="AssemblyInfo.cs">
using System;
using System.Data;
using Microsoft.SqlServer.Dts.Runtime;
using System.Windows.Forms;

namespace ST_c1460709233e45a7af989d19c79a53aa
{
	[Microsoft.SqlServer.Dts.Tasks.ScriptTask.SSISScriptTaskEntryPointAttribute]
	public partial class ScriptMain : Microsoft.SqlServer.Dts.Tasks.ScriptTask.VSTARTScriptObjectModelBase
	{
		public void Main()
	{
		int waitTimes = Convert.ToInt32(Dts.Variables["$Project::WaitTimes_1"].Value);

		System.Threading.Thread.Sleep(waitTimes*1000);
		Dts.TaskResult = (int)ScriptResults.Success;
	}
		enum ScriptResults
	{
		Success = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Success,
		Failure = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Failure
	};

	}
}
                                                </File>
                                            </Files>
                                            <ReadOnlyVariables>
                                                <Variable Namespace="$Project" DataType="Int32" VariableName="WaitTimes_1" />
                                            </ReadOnlyVariables>
                                            <ReadWriteVariables /> 
                                        </ScriptTaskProject>
                                    </ScriptTaskProject>
                                </Script>

                                <ExecutePackage Name="<#=varPackage2#>">
                                    <PrecedenceConstraints>
                                        <Inputs>
                                            <Input OutputPathName="<#=varScriptName#>.Output"/>
                                        </Inputs>
                                    </PrecedenceConstraints>
                                    <ExternalProjectPackage Package="<#=varPackage#>"/>
                                    <ParameterBindings>
                                        <ParameterBinding VariableName="Audit.AuditBatchID" Name="BatchID" />
                                        <ParameterBinding VariableName="Audit.AuditProcessLogID" Name="ProcessLogParentID" />
                                    </ParameterBindings>
                                </ExecutePackage>
                                
                                <Script ProjectCoreName="<#=varScriptCoreName2#>" Name="<#=varScriptName2#>">
                                    <PrecedenceConstraints>
                                        <Inputs>
                                            <Input OutputPathName="<#=varPackage2#>.Output" EvaluationValue="Failure"/>
                                        </Inputs>
                                    </PrecedenceConstraints>
                                    <ScriptTaskProject>
                                        <ScriptTaskProject ProjectCoreName="<#=varScriptCoreName2#>" Name="<#=varScriptTaskName2#>">
                                            <AssemblyReferences>
                                                <AssemblyReference AssemblyPath="Microsoft.SqlServer.ManagedDTS.dll" />
                                                <AssemblyReference AssemblyPath="Microsoft.SqlServer.ScriptTask.dll" />
                                                <AssemblyReference AssemblyPath="System.dll" />
                                                <AssemblyReference AssemblyPath="System.AddIn.dll" />
                                                <AssemblyReference AssemblyPath="System.Data.dll" />
                                                <AssemblyReference AssemblyPath="System.Windows.Forms.dll" />
                                                <AssemblyReference AssemblyPath="System.Xml.dll" />
                                            </AssemblyReferences>
                                            <Files>
                                                <File Path="AssemblyInfo.cs">
using System;
using System.Data;
using Microsoft.SqlServer.Dts.Runtime;
using System.Windows.Forms;

namespace ST_c1460709233e45a7af989d19c79a53aa
{
	[Microsoft.SqlServer.Dts.Tasks.ScriptTask.SSISScriptTaskEntryPointAttribute]
	public partial class ScriptMain : Microsoft.SqlServer.Dts.Tasks.ScriptTask.VSTARTScriptObjectModelBase
	{
		public void Main()
	{
		int waitTimes = Convert.ToInt32(Dts.Variables["$Project::WaitTimes_2"].Value);

		System.Threading.Thread.Sleep(waitTimes*1000);
		Dts.TaskResult = (int)ScriptResults.Success;
	}
		enum ScriptResults
	{
		Success = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Success,
		Failure = Microsoft.SqlServer.Dts.Runtime.DTSExecResult.Failure
	};

	}
}
                                                </File>
                                            </Files>
                                            <ReadOnlyVariables>
                                                <Variable Namespace="$Project" DataType="Int32" VariableName="WaitTimes_2" />
                                            </ReadOnlyVariables>
                                            <ReadWriteVariables /> 
                                        </ScriptTaskProject>
                                    </ScriptTaskProject>
                                </Script>

                                <ExecutePackage Name="<#=varPackage3#>" FailParentOnFailure="true">
                                    <PrecedenceConstraints>
                                        <Inputs>
                                            <Input OutputPathName="<#=varScriptName2#>.Output"/>
                                        </Inputs>
                                    </PrecedenceConstraints>
                                    <ExternalProjectPackage Package="<#=varPackage#>"/>
                                    <ParameterBindings>
                                        <ParameterBinding VariableName="Audit.AuditBatchID" Name="BatchID" />
                                        <ParameterBinding VariableName="Audit.AuditProcessLogID" Name="ProcessLogParentID" />
                                    </ParameterBindings>
                                </ExecutePackage>
                            <#}#>
                                
                        </Tasks>
                    </Container>

                    <ExecuteSQL Name="SQL Finish Audit Package <#=varName#>" ConnectionName ="<#=SystemConnection#>" ResultSet="None">
                        <DirectInput>EXECUTE [Logging].[PrcLoggingPackageExecution] @Action = ?,@BatchAction = ?,@BatchID = ?,@ProcessLogID = ?</DirectInput>
                        <Parameters>
                            <Parameter Name="0" VariableName="Audit.AuditActionFinish" Direction="Input" DataType="String"/>
                            <Parameter Name="1" VariableName="Audit.AuditBatchActionNone" Direction="Input" DataType="String"/>
                            <Parameter Name="2" VariableName="Audit.AuditBatchID" Direction="Input" DataType="Int64"/>
                            <Parameter Name="3" VariableName="Audit.AuditProcessLogID" Direction="Input" DataType="Int64"/>
                        </Parameters>
                    </ExecuteSQL>
                </Tasks>

                <Events>
                    <Event Name="Package Error" ConstraintMode="Linear" EventType="OnError">
                        <Tasks>
                        <ExecuteSQL Name="SQL Error Audit Package <#=varName#>" ConnectionName ="<#=SystemConnection#>" ResultSet="None">
                            <DirectInput>exec [Logging].[PrcLogMessage]@ProcessLogID = ?,@BatchID = ?,@SourceName = ?,@EventCode = ?,@EventDescription = ?</DirectInput>
                            <Parameters>
                                <Parameter Name="0" VariableName="Audit.AuditProcessLogID" Direction="Input" DataType="Int64"/>
                                <Parameter Name="1" VariableName="Audit.AuditBatchID" Direction="Input" DataType="Int64"/>
                                <Parameter Name="2" VariableName="User.PackageName" Direction="Input" DataType="String"/>
                                <Parameter Name="3" VariableName="System.ErrorCode" Direction="Input" DataType="Int32"/>
                                <Parameter Name="4" VariableName="System.ErrorDescription" Direction="Input" DataType="String" />
                            </Parameters>
                        </ExecuteSQL>
                        </Tasks>
                    </Event>
                </Events>
            </Package>
        <#}#>
    </Packages>
</Biml>